<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Design Algorithms and Analysis</title>
    <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;600&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: #0a0f1c;
            --bg-secondary: #151f32;
            --accent: #94a3b8;
            --text-primary: #f8fafc;
            --text-secondary: #cbd5e1;
            --highlight: #38bdf8;
            --card-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
        }

        @property --gradient-angle {
            syntax: '<angle>';
            initial-value: 0deg;
            inherits: false;
        }

        body {
            font-family: 'Space Grotesk', sans-serif;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            overflow-x: hidden;
            perspective: 1000px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 2rem;
        }

        .header {
            height: 100vh;
            display: flex;
            align-items: center;
            position: relative;
            overflow: hidden;
            justify-content: center;
        }

        .header::before {
            content: '';
            position: absolute;
            inset: 0;
            background: radial-gradient(circle at 50% 50%, rgba(56, 189, 248, 0.1), transparent);
            opacity: 0;
            animation: pulseGradient 8s ease-in-out infinite;
        }

        .header-content {
            position: relative;
            z-index: 1;
            opacity: 0;
            transform: translateY(30px) rotateX(10deg);
            animation: heroEntrance 1.5s cubic-bezier(0.2, 0.8, 0.2, 1) forwards;
            text-align: center;
        }

        .title {
            font-size: clamp(2.5rem, 5vw, 4.5rem);
            font-weight: 600;
            margin-bottom: 1rem;
            line-height: 1.2;
            background: linear-gradient(var(--gradient-angle), var(--highlight), var(--text-primary));
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            animation: rotateGradient 10s linear infinite;
        }

        .subtitle {
            font-size: clamp(1rem, 2vw, 1.25rem);
            color: var(--accent);
            max-width: 600px;
            margin-bottom: 2rem;
            opacity: 0;
            transform: translateY(20px);
            animation: fadeSlideUp 0.8s ease forwards 0.5s;
        }

        .section {
            padding: 3rem;
            margin-bottom: 2rem;
            background-color: var(--bg-secondary);
            border-radius: 12px;
            box-shadow: var(--card-shadow);
            opacity: 0;
            transform: translateY(30px);
            transition: all 0.8s cubic-bezier(0.2, 0.8, 0.2, 1);
        }

        .section.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .section-title {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            position: relative;
            display: inline-block;
            color: var(--highlight);
        }

        .section-title::after {
            content: '';
            position: absolute;
            bottom: -10px;
            left: 0;
            width: 100%;
            height: 2px;
            background: linear-gradient(90deg, transparent, var(--highlight), transparent);
            transform: scaleX(0);
            transform-origin: center;
            animation: expandLine 0.6s ease forwards 0.5s;
        }

        @keyframes pulseGradient {
            0%, 100% { opacity: 0.1; }
            50% { opacity: 0.2; }
        }

        @keyframes rotateGradient {
            0% { background-position: 0%; }
            100% { background-position: 100%; }
        }

        @keyframes heroEntrance {
            to {
                opacity: 1;
                transform: translateY(0) rotateX(0);
            }
        }

        @keyframes fadeSlideUp {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes expandLine {
            to {
                transform: scaleX(1);
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <div class="header-content">
                <h1 class="title">Design Algorithms and Analysis</h1>
                <p class="subtitle">A deep dive into the intricacies of algorithm design, problem-solving techniques, and optimization strategies.</p>
            </div>
        </header>

        <section class="section visible">
            <h2 class="section-title">1. Algorithmic Problem-Solving</h2>
            <p>Algorithmic problem-solving is the backbone of computer science and software engineering. It involves breaking down a complex problem into smaller, manageable subproblems that can be solved individually. Understanding the fundamental concepts of recursion, backtracking, and divide-and-conquer is crucial for solving real-world problems efficiently.</p>
            <ul>
                <li><strong>Recursion:</strong> Solve problems by breaking them into smaller, similar subproblems. Examples: Fibonacci sequence, Tower of Hanoi.</li>
                <li><strong>Backtracking:</strong> Systematically explore possible solutions and backtrack when necessary. Example: N-Queens problem.</li>
            </ul>
        </section>

        <section class="section visible">
            <h2 class="section-title">2. Importance of Algorithm Efficiency</h2>
            <p>Efficiency is key when it comes to algorithms. Understanding the time and space complexity of an algorithm helps in selecting the right approach to solve a given problem. This is particularly important in large-scale applications where performance and resource consumption are critical factors.</p>
            <ul>
                <li><strong>Time Complexity:</strong> Evaluate the number of steps an algorithm takes to complete.</li>
                <li><strong>Space Complexity:</strong> Analyze memory usage during execution.</li>
            </ul>
        </section>

        <section class="section visible">
            <h2 class="section-title">3. Essential Data Structures</h2>
            <p>Data structures are essential tools for organizing and manipulating data in an efficient manner. Choosing the right data structure can dramatically improve the performance of your algorithms.</p>
            <ul>
                <li><strong>Trees:</strong> Efficiently represent hierarchical data. Examples: Binary Search Tree (BST), AVL Tree.</li>
                <li><strong>Graphs:</strong> Solve network and connectivity problems using nodes and edges.</li>
                <li><strong>Hash Tables:</strong> Provide constant-time lookups for average cases.</li>
                <li><strong>Tries:</strong> Optimize string searches, as seen in autocomplete features.</li>
            </ul>
        </section>

        <section class="section visible">
            <h2 class="section-title">4. Graph Algorithms</h2>
            <p>Graph algorithms are crucial in solving problems related to networks, such as finding the shortest path, exploring all nodes, and determining the minimum spanning tree. Understanding how to implement these algorithms is vital for applications like navigation systems, social networks, and optimization problems.</p>
            <ul>
                <li><strong>Depth-First Search (DFS):</strong> Explore as deep as possible in one branch before backtracking.</li>
                <li><strong>Breadth-First Search (BFS):</strong> Explore all nodes at one level before moving to the next.</li>
                <li><strong>Shortest Path Algorithms:</strong> Algorithms like Dijkstra and Bellman-Ford find optimal routes.</li>
                <li><strong>Minimum Spanning Tree:</strong> Use Prim’s or Kruskal’s algorithms to connect nodes with minimal total weight.</li>
            </ul>
        </section>

        <footer>
            &copy; 2024 <a href="#">Design Algorithms and Analysis</a>
        </footer>
    </div>
</body>
</html>
